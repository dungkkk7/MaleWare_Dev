Chúng ta sẽ phân tích sâu hơn về các tham số trong `DllMain` để hiểu rõ cách chúng hoạt động trong hệ thống Windows.

---

## **1. `HINSTANCE hinstDLL` - Handle của DLL trong bộ nhớ**
- `HINSTANCE` (hoặc `HMODULE`, vì về bản chất hai kiểu này giống nhau) là một con trỏ hoặc handle trỏ đến vị trí bộ nhớ nơi DLL được nạp vào trong tiến trình.
- Khi một DLL được tải vào tiến trình (`DLL_PROCESS_ATTACH`), Windows cấp phát một vùng bộ nhớ để chứa DLL này. `hinstDLL` là địa chỉ cơ sở của vùng nhớ đó.

### **Ví dụ cách sử dụng `hinstDLL`**
Bạn có thể dùng `hinstDLL` để lấy thông tin về DLL hoặc truy xuất tài nguyên bên trong nó:

```cpp
wchar_t path[MAX_PATH];
GetModuleFileName(hinstDLL, path, MAX_PATH);
MessageBox(NULL, path, L"Path of DLL", MB_OK);
```
Đoạn code này lấy đường dẫn đầy đủ của DLL khi nó được nạp vào tiến trình.

---

## **2. `DWORD fdwReason` - Lý do tại sao DLL được gọi**
Tham số `fdwReason` xác định sự kiện nào đang xảy ra với DLL. Nó có thể có bốn giá trị:

### **2.1. `DLL_PROCESS_ATTACH` - Khi DLL được tải vào một tiến trình**
- Xảy ra khi DLL được nạp vào bộ nhớ của tiến trình (do `LoadLibrary` hoặc do tiến trình cần nó khi khởi động).
- Chỉ gọi một lần trong suốt vòng đời của tiến trình.
- Thích hợp để thực hiện các thao tác khởi tạo như:
  - Cấp phát bộ nhớ động (`HeapCreate`).
  - Tạo thread (`CreateThread`).
  - Hook API để thay đổi hành vi của ứng dụng.

#### **Ví dụ: Ghi log khi DLL được nạp**
```cpp
case DLL_PROCESS_ATTACH:
    MessageBox(NULL, L"DLL Loaded into Process!", L"Notification", MB_OK);
    break;
```

---

### **2.2. `DLL_PROCESS_DETACH` - Khi DLL bị dỡ khỏi tiến trình**
- Xảy ra khi tiến trình kết thúc hoặc khi `FreeLibrary` được gọi.
- Được dùng để giải phóng tài nguyên đã cấp phát trong `DLL_PROCESS_ATTACH`.

#### **Ví dụ: Đóng file log khi DLL bị gỡ**
```cpp
case DLL_PROCESS_DETACH:
    MessageBox(NULL, L"DLL Unloaded from Process!", L"Notification", MB_OK);
    break;
```

---

### **2.3. `DLL_THREAD_ATTACH` - Khi một thread mới được tạo**
- Xảy ra khi một thread mới trong tiến trình được khởi tạo.
- **Chỉ được gọi nếu DLL đã được liên kết tĩnh với tiến trình**.
- Không nên làm các thao tác tốn thời gian ở đây vì nó làm chậm tốc độ tạo thread.

#### **Ví dụ: Ghi log khi thread mới được tạo**

```cpp
case DLL_THREAD_ATTACH:
    MessageBox(NULL, L"Thread Created!", L"Notification", MB_OK);
    break;
```

---

### **2.4. `DLL_THREAD_DETACH` - Khi một thread kết thúc**
- Xảy ra khi một thread trong tiến trình bị đóng.
- Dùng để dọn dẹp bộ nhớ thread-local.

#### **Ví dụ: Giải phóng tài nguyên của thread**
```cpp
case DLL_THREAD_DETACH:
    MessageBox(NULL, L"Thread Exited!", L"Notification", MB_OK);
    break;
```

---

## **3. `LPVOID lpvReserved` - Dữ liệu bổ sung**

- Đây là một con trỏ tùy chọn chứa dữ liệu bổ sung khi DLL được tải hoặc dỡ bỏ.
- **Nếu tiến trình đang kết thúc**, `lpvReserved` **sẽ không phải là NULL** (nó có thể chứa giá trị nội bộ của hệ thống).
- **Nếu `FreeLibrary` được gọi**, `lpvReserved` sẽ **luôn là NULL**.

### **Cách sử dụng `lpvReserved`**
Nếu bạn muốn xác định xem DLL có bị dỡ do `FreeLibrary` hay do tiến trình kết thúc:
```cpp
case DLL_PROCESS_DETACH:
    if (lpvReserved == NULL) {
        MessageBox(NULL, L"Process called FreeLibrary!", L"Notification", MB_OK);
    } else {
        MessageBox(NULL, L"Process is terminating!", L"Notification", MB_OK);
    }
    break;
```

---

## **4. Tổng kết**
| Giá trị `fdwReason` | Khi nào được gọi                             | Ý nghĩa                          |
|---------------------|-----------------|----------------------------|
| `DLL_PROCESS_ATTACH`| Khi DLL được tải vào tiến trình              | Khởi tạo tài nguyên              |
| `DLL_PROCESS_DETACH`| Khi DLL bị gỡ khỏi tiến trình                | Giải phóng tài nguyên            |
| `DLL_THREAD_ATTACH` | Khi một thread mới được tạo trong tiến trình | Thường không cần dùng            |
| `DLL_THREAD_DETACH` | Khi một thread kết thúc                      | Dọn dẹp bộ nhớ cục bộ của thread |

Tham số `lpvReserved` có thể giúp xác định xem DLL bị dỡ do tiến trình kết thúc hay do `FreeLibrary`.

Nếu bạn muốn kiểm soát tốt hơn hành vi của DLL trong hệ thống, có thể kết hợp các API như:
- `GetModuleHandle` (lấy handle của DLL đang chạy).
- `GetProcAddress` (lấy địa chỉ của một hàm trong DLL).
- `LoadLibrary` và `FreeLibrary` để tải/gỡ DLL động.
