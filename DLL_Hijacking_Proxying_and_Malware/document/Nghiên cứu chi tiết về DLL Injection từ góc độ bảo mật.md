Nghiên cứu chi tiết về các kỹ thuật bảo mật liên quan đến DLL Injection, bao gồm:

1. **Cách bảo vệ hệ thống khỏi DLL Injection**: Các phương pháp phát hiện và ngăn chặn kỹ thuật này bằng cách sử dụng công cụ bảo mật, chính sách hệ thống, và giám sát hành vi tiến trình.

2. **Nghiên cứu chi tiết về từng kỹ thuật DLL Injection**: Bao gồm cách chúng hoạt động, ứng dụng thực tế, và các biện pháp phòng ngừa.

3. **Phân tích cách hoạt động của các cơ chế phát hiện như Windows Defender, EDR**: Cách các công cụ bảo mật nhận diện DLL Injection và các biện pháp phòng thủ hiệu quả.


# Nghiên cứu chi tiết về DLL Injection từ góc độ bảo mật

**DLL Injection** (tiêm DLL) là kỹ thuật chèn mã độc vào không gian của một tiến trình hợp pháp bằng cách tải một thư viện DLL tùy ý vào tiến trình đó. Điều này cho phép mã độc chạy dưới danh nghĩa tiến trình tin cậy, giúp kẻ tấn công **ẩn dấu hoạt động** và **né tránh bị phát hiện** bởi các giải pháp bảo mật ([Process Injection: Dynamic-link Library Injection, Sub-technique T1055.001 - Enterprise | MITRE ATT&CK®](https://attack.mitre.org/techniques/T1055/001/#:~:text=Running%20code%20in%20the%20context,masked%20under%20a%20legitimate%20process)). Dưới đây là hướng dẫn chi tiết cách bảo vệ hệ thống khỏi DLL Injection, phân tích từng kỹ thuật DLL Injection và cách các cơ chế phát hiện (Windows Defender, EDR) hoạt động.


## 1. Cách bảo vệ hệ thống khỏi DLL Injection

### Giám sát tiến trình để phát hiện DLL Injection

Việc **giám sát hành vi tiến trình** có thể giúp phát hiện sớm kỹ thuật DLL Injection. Các dấu hiệu điển hình bao gồm tiến trình gọi các hàm như `VirtualAllocEx`, `WriteProcessMemory` và `CreateRemoteThread` để chèn mã vào tiến trình khác. Một số phương pháp và công cụ giám sát hiệu quả:

- **Sysmon (System Monitor)**: Sysmon ghi lại chi tiết các sự kiện hệ thống. Đặc biệt, **Sysmon Event ID 8** có thể cảnh báo khi một luồng từ tiến trình này được tạo trong tiến trình khác – dấu hiệu của process injection ([Process Injection Detection with Sysmon](https://letsdefend.io/blog/process-injection-detection-with-sysmon#:~:text=)). Lưu ý rằng cần **cấu hình Sysmon phù hợp** thì mới bắt được các hành vi DLL Injection; cấu hình mặc định có thể bỏ lọt nếu loại trừ các thư viện hệ thống thường dùng (ví dụ cấu hình Sysmon phổ biến của SwiftOnSecurity từng bỏ sót injection do loại trừ kernel32.dll) ([Studying Sysmon's Ability to Detect Process Injections Using Different Configuration Schemas – Shellcode.Blog – Personal Computer Security Blog.](https://shellcode.blog/Studying_Sysmon_Ability_to_Detect_Process_Injections/#:~:text=Sysmon%20is%20a%20very%20helpful,identifier%20for%20a%20CreateRemoteThread%20event)). Sau khi cài Sysmon, bạn nên điều chỉnh rule cho Event ID 8 để không loại trừ các module quan trọng, rồi theo dõi log tại “Applications and Services Logs/Microsoft/Windows/Sysmon/Operational” trên Event Viewer.

- **Process Explorer**: Công cụ GUI trong bộ Sysinternals này cho phép xem **toàn bộ DLL đang được tải trong một tiến trình**. Bật **View > Lower Pane > DLLs** (hoặc Ctrl+D) để liệt kê các module DLL trong tiến trình nghi vấn ([Using Process Explorer to list dlls running under Outlook.exe - Outlook | Microsoft Learn](https://learn.microsoft.com/en-us/outlook/troubleshoot/performance/using-process-explorer-to-list-dlls-running-under-outlook-exe#:~:text=2.%20Double,txt)). Bạn có thể **lọc các DLL không thuộc Microsoft** để nhanh chóng phát hiện thư viện lạ trong tiến trình hợp pháp ([Using Process Explorer to list dlls running under Outlook.exe - Outlook | Microsoft Learn](https://learn.microsoft.com/en-us/outlook/troubleshoot/performance/using-process-explorer-to-list-dlls-running-under-outlook-exe#:~:text=Analyzing%20the%20Process%20Explorer%20Output)). Nếu thấy một DLL bất thường (ví dụ tên lạ, đường dẫn trong thư mục tạm, không có chữ ký số), đó có thể là dấu hiệu của DLL Injection. Process Explorer còn cho phép tìm kiếm global (Find Handle or DLL) để xem DLL độc hại đang “ẩn” trong tiến trình nào ([How to determine the process that currently using a specific DLL](https://stackoverflow.com/questions/14600811/how-to-determine-the-process-that-currently-using-a-specific-dll#:~:text=DLL%20stackoverflow,file%20you%20are%20interested%20in)).

- **PE-sieve (HollowsHunter)**: Đây là công cụ mã nguồn mở chuyên dò quét **mã cấy ghép trong bộ nhớ tiến trình**. PE-sieve có thể phát hiện **PE bị thay thế hoặc tiêm vào**, shellcode, hook, patch in-memory... Công cụ nhận diện được các kỹ thuật như **Process Hollowing, Process Doppelgänging, Reflective DLL Injection**,… và trích xuất vùng nhớ nghi ngờ để phân tích ([PE-sieve: PE-sieve](https://hasherezade.github.io/pe-sieve/index.html#:~:text=PE,Doppelg%C3%A4nging%2C%20Reflective%20DLL%20Injection%2C%20etc)) ([PE-sieve: PE-sieve](https://hasherezade.github.io/pe-sieve/index.html#:~:text=Recognizes%20and%20dumps%20variety%20of,Doppelg%C3%A4nging%2C%20Reflective%20DLL%20Injection%2C%20etc)). Trong môi trường giám sát, bạn có thể chạy PE-sieve định kỳ hoặc khi nghi ngờ, để kiểm tra tiến trình và **phát hiện DLL lạ không có file trên đĩa** hay các đoạn mã thực thi không thuộc module hợp lệ.

### Sử dụng Windows Defender và chính sách bảo mật để ngăn chặn DLL Injection

Bên cạnh giám sát, cần **cấu hình các biện pháp phòng vệ chủ động** trên Windows nhằm ngăn chặn hoặc hạn chế DLL Injection:

1. **Bật các quy tắc Attack Surface Reduction (ASR)**: Microsoft Defender cung cấp các quy tắc ASR để chặn hành vi tấn công phổ biến. Ví dụ, quy tắc **“Block Office applications from injecting code into other processes”** sẽ **ngăn chặn ứng dụng Office (Word, Excel, Adobe Reader...) tiêm mã vào tiến trình khác** ([Attack surface reduction rules reference - Microsoft Defender for Endpoint | Microsoft Learn](https://learn.microsoft.com/en-us/defender-endpoint/attack-surface-reduction-rules-reference#:~:text=Block%20Office%20applications%20from%20creating,USB%20Audit%20or%20Block%20Y)) – vốn là kỹ thuật mà macro độc hại hay dùng để chèn DLL. Hãy kích hoạt các ASR rule phù hợp (qua Windows Security > Virus & threat protection > Virus & threat protection settings > Manage settings > Controlled folder access > Configure ASR rules, hoặc qua Group Policy/Intune trong môi trường doanh nghiệp).

2. **Bật cơ chế kiểm soát ứng dụng (AppLocker/WDAC)**: Giải pháp hiệu quả nhất để chặn mọi loại DLL Injection là triển khai **AppLocker ở chế độ whitelist** (chỉ cho phép chạy các ứng dụng/DLL đã được duyệt) ([windows - Prevent Process Hijacking and injection? - Information Security Stack Exchange](https://security.stackexchange.com/questions/161861/prevent-process-hijacking-and-injection#:~:text=or%20DLLs)). AppLocker có thể áp dụng quy tắc cho thư viện DLL; cấu hình đúng sẽ **ngăn DLL không được phép (ví dụ DLL độc hại trong AppData, Temp)** tải vào tiến trình. Tương tự, **Windows Defender Application Control (WDAC)** trên Windows 10+ cho phép định nghĩa chính sách chỉ cho phép thực thi mã đã ký số hoặc từ nhà phát hành tin cậy. Bằng cách **giới hạn DLL được tải từ thư mục hoặc nhà cung cấp tin cậy** và yêu cầu **chữ ký số hợp lệ** cho DLL, bạn sẽ giảm thiểu nguy cơ DLL lạ được nạp vào tiến trình ([Mitigate DLL Injection Attacks - Apriorit](https://www.apriorit.com/dev-blog/secure-windows-software-against-dll-attacks#:~:text=To%20determine%20that%20a%20DLL,or%20vendor%20and%20source%20validation)). Triển khai AppLocker/WDAC qua Group Policy trên domain để đảm bảo toàn bộ máy trong doanh nghiệp tuân thủ chính sách này.

3. **Cấu hình Windows Defender Antivirus**: Đảm bảo **Real-time protection** luôn bật và **Cloud-delivered protection** được kích hoạt để Defender kịp thời nhận diện mẫu DLL độc. Windows Defender hiện đại có khả năng giám sát hành vi, nếu phát hiện tiến trình gọi các API bất thường như tạo thread từ xa hoặc sửa bộ nhớ tiến trình khác, nó có thể chặn lại. Ngoài ra, bật **Tamper Protection** để malware không thể tự vô hiệu hóa Defender. Các bản Windows 10 trở lên còn có tính năng **AMSI (Antimalware Scan Interface)** – tự động quét mã thực thi trong script hoặc macro – giúp phát hiện sớm payload DLL nếu chúng được giải mã ra bộ nhớ thông qua script độc hại.

4. **Bảo vệ các tiến trình nhạy cảm**: Kích hoạt những cơ chế bảo vệ đặc thù cho tiến trình hệ thống quan trọng. Chẳng hạn, bật **LSA Protection** (qua registry hoặc Local Security Policy) để chạy tiến trình LSASS dưới dạng **Protected Process Light**, giúp chặn code injection vào LSASS (ngăn chặn công cụ như Mimikatz tiêm DLL để trích xuất mật khẩu). Tương tự, các phần mềm bảo mật (EDR/AV) thường chạy dưới dạng protected process – đảm bảo malware không thể tiêm DLL hoặc can thiệp vào tiến trình của chúng. Trong lập trình nội bộ, nếu phát triển ứng dụng nhạy cảm, có thể sử dụng API **UpdateProcThreadAttribute** với thuộc tính **MitigationPolicy** để **chỉ cho phép DLL Microsoft hợp lệ được inject** vào tiến trình đó ([Preventing 3rd Party DLLs from Injecting into your Malware | Red Team Notes](https://www.ired.team/offensive-security/defense-evasion/preventing-3rd-party-dlls-from-injecting-into-your-processes#:~:text=It%20is%20possible%20to%20launch,their%20DLLs%20into%20running%20process)). Đây là cách kẻ tấn công cao cấp tự bảo vệ tiến trình malware khỏi sự can thiệp của EDR, nhưng doanh nghiệp cũng có thể tận dụng để bảo vệ ứng dụng quan trọng khỏi DLL ngoại lai.

## 2. Nghiên cứu chi tiết về từng kỹ thuật DLL Injection

Các kỹ thuật DLL Injection rất đa dạng, kẻ tấn công thường kết hợp nhiều thủ thuật để gia tăng khả năng **ẩn mình** trước hệ thống phòng thủ. Dưới đây là phân tích chi tiết về từng kỹ thuật, bao gồm cách thức hoạt động và mục đích **né tránh phát hiện** của chúng:

### 2.1. Làm rối mã (Obfuscation)

**Obfuscation** là kỹ thuật làm rối và biến đổi mã nhằm che giấu ý đồ thực sự của malware. Kẻ tấn công có thể thay đổi cấu trúc code, thêm mã giả, thay đổi tên hàm/biến, hoặc sắp xếp lại luồng thực thi để mã độc **trở nên khó nhận diện** đối với các giải pháp quét dựa trên signature. Ví dụ, nhiều malware sử dụng thủ thuật **polymorphic hoặc metamorphic** – tự động biến đổi code của chính nó mỗi khi lây nhiễm – tạo ra hàng loạt biến thể với hình thái khác nhau ([MALWARE DETECTION : EVASION TECHNIQUES - CYFIRMA](https://www.cyfirma.com/outofband/malware-detection-evasion-techniques/#:~:text=Polymorphic%20and%20Metamorphic%20Malware%3A%20Polymorphic,underlying%20code%20while%20maintaining%20its)). Nhờ đó, **không có một mẫu chữ ký cố định nào** mà antivirus có thể dễ dàng nhận dạng, buộc các giải pháp phải dựa vào phân tích hành vi và heuristic nâng cao thay vì chỉ dựa trên mẫu mã. Code obfuscation cũng **ẩn các chuỗi (strings) nhạy cảm**, API quan trọng bằng cách mã hóa hoặc chia nhỏ chúng, làm cho việc phân tích tĩnh và đảo ngược khó khăn hơn ([MALWARE DETECTION : EVASION TECHNIQUES - CYFIRMA](https://www.cyfirma.com/outofband/malware-detection-evasion-techniques/#:~:text=Code%20Obfuscation%3A%20Code%20obfuscation%20in,predefined%20patterns%20of%20known%20threats)). Mục tiêu cuối cùng của obfuscation trong DLL Injection là để **payload DLL hoặc shellcode trông vô hại**, tránh bị phát hiện khi nằm trên đĩa hoặc khi được quét trong bộ nhớ, cho phép mã độc lọt qua lớp bảo vệ ban đầu.

### 2.2. Gọi syscalls trực tiếp (Direct Syscalls)

Các giải pháp EDR/AV thường sử dụng kỹ thuật **hook API** – tức chèn mã giám sát vào ngay các hàm Windows API phổ biến – để bắt các hành vi nghi ngờ. Chẳng hạn, khi một tiến trình gọi hàm `CreateRemoteThread` hoặc `LoadLibrary`, mã hook của EDR đã được chèn vào ntdll.dll sẽ chuyển hướng dòng lệnh sang mô-đun giám sát để phân tích xem cuộc gọi có độc hại hay không ([AV/EDR Bypass Using Direct Syscalls - Red Team Tactics - PwnedC0ffee](https://pwnedcoffee.com/blog/bypassing-antivirus-using-direct-system-calls/#:~:text=)) ([AV/EDR Bypass Using Direct Syscalls - Red Team Tactics - PwnedC0ffee](https://pwnedcoffee.com/blog/bypassing-antivirus-using-direct-system-calls/#:~:text=The%20Native%20API%20%28NTDLL,DLL)). Để né sự giám sát này, malware chuyển sang **Direct Syscalls** – thay vì gọi Windows API bình thường, malware sẽ **gọi thẳng syscall của Windows kernel**. Cụ thể, mỗi hàm API tương ứng với một mã số syscall; kẻ tấn công có thể lấy số hiệu syscall từ ntdll.dll rồi thực hiện lệnh CPU `syscall`/`sysenter` trực tiếp. Cách này bỏ qua hoàn toàn tầng API của Windows (ntdll.dll), đồng nghĩa với việc **bỏ qua luôn các hook user-mode của EDR**. Kết quả là EDR/AV không “nhìn thấy” gì khi malware thực hiện hành vi nguy hiểm ở chế độ kernel, bởi chúng chỉ giám sát các lời gọi ở chế độ người dùng ([Detecting Direct Syscalls with Frida | PassTheHashBrowns](https://passthehashbrowns.github.io/detecting-direct-syscalls-with-frida#:~:text=EDR%20products%20were%20largely%20forced,userland%20hooking%20will%20be%20blind)). Kỹ thuật này làm **mù cơ chế giám sát userland** của Defender/EDR, cho phép malware thực thi các hành vi như cấp phát bộ nhớ thực thi, ghi mã, tạo thread… trong tiến trình mục tiêu mà không bị chặn. Hiện nay đã có những dự án mã nguồn mở (như **SysWhispers, Hell’s Gate**…) hỗ trợ tự động lấy syscall và tạo hàm syscall phù hợp cho từng phiên bản Windows. Mặc dù direct syscalls ban đầu có thể qua mặt nhiều sản phẩm bảo mật, các EDR tiên tiến đang phát triển cách phát hiện chúng (xem §3). Tuy nhiên, đây vẫn là kỹ thuật nguy hiểm, giúp malware **tránh được hầu hết cơ chế hook API truyền thống** của Windows Defender và EDR trong việc tiêm DLL.

### 2.3. Reflective DLL Injection (Tải DLL phản xạ trong bộ nhớ)

**Reflective DLL Injection** là kỹ thuật nạp một DLL trực tiếp từ bộ nhớ mà **không cần lưu DLL đó trên ổ đĩa** của máy nạn nhân. Điều này được thực hiện nhờ một đoạn mã loader đặc biệt (thường gọi là *Reflective Loader*) được tích hợp bên trong DLL độc hại. Cơ chế hoạt động tóm tắt như sau: mã độc alô cấp phát bộ nhớ trong tiến trình đích, tự ghi toàn bộ nội dung file DLL độc (ở dạng nhị phân) vào vùng nhớ đó, sau đó chuyển điều khiển đến hàm ReflectiveLoader của DLL vừa ghi. Hàm loader này sẽ **tự thực hiện các bước load DLL như hệ điều hành thường làm**: nó tính toán vị trí base của DLL trong bộ nhớ, tự parse và áp dụng các bảng import, thực hiện relocation, rồi cuối cùng gọi hàm entry point (DllMain) của DLL ngay trong không gian tiến trình mục tiêu ([Reflective DLL Injection | Red Team Notes](https://www.ired.team/offensive-security/code-injection-process-injection/reflective-dll-injection#:~:text=Loading%20DLL%20from%20memory)) ([Reflective DLL Injection | Red Team Notes](https://www.ired.team/offensive-security/code-injection-process-injection/reflective-dll-injection#:~:text=The%20way%20the%20reflective%20injection,original%20author%20Stephen%20Fewer%20here)). Tất cả diễn ra **hoàn toàn trong bộ nhớ** mà **không dùng đến Windows API LoadLibrary** thông thường.

Lợi thế bảo mật của phương pháp này là **tính fileless (không chạm đĩa)**: vì DLL không bao giờ tồn tại như một file trên ổ, nên **tránh được sự theo dõi của hệ điều hành và antivirus**. Windows bình thường sẽ ghi nhận sự kiện load module (DLL) khi dùng LoadLibrary, còn ở đây DLL được nạp ngầm nên **danh sách module của tiến trình vẫn chỉ hiển thị các file hợp lệ trên đĩa**. Mã độc do đó “ẩn mình” dưới vỏ bọc tiến trình sạch sẽ – **các module loaded của tiến trình vẫn trỏ đến file hợp lệ trên disk** như hình thường thấy ([Uncovering cross-process injection with Windows Defender ATP | Microsoft Security Blog](https://www.microsoft.com/en-us/security/blog/2017/03/08/uncovering-cross-process-injection-with-windows-defender-atp/#:~:text=Cross,be%20used%20for%20organizational%20persistence)). Kỹ thuật reflective loading cũng **tránh tạo dấu vết trên ổ đĩa** để forensic, và **né cơ chế giám sát module** của Windows (ví dụ Windows không ghi log Event Tracing cho việc load DLL nếu không dùng API chính thống). Microsoft cũng ghi nhận reflective DLL injection giúp malware **qua mặt cơ chế theo dõi module thực thi của OS** ([Anti-malware Scan Interface (AMSI) integration with Microsoft Defender Antivirus - Microsoft Defender for Endpoint | Microsoft Learn](https://learn.microsoft.com/en-us/defender-endpoint/amsi-on-mdav#:~:text=,HackTool%3AWin32%2FMikatz%21dha)). Một ví dụ nổi tiếng là công cụ Mimikatz có chức năng Reflective DLL Injection để tự nạp vào LSASS. Với reflective injection, mã DLL độc hại hoạt động hoàn toàn trong RAM tiến trình đích, rất khó bị phát hiện bằng quét tệp thông thường – chỉ các giải pháp EDR có cơ chế quét bộ nhớ (memory scanning) hoặc phát hiện hành vi bất thường trong tiến trình mới có thể nhận ra.

### 2.4. Process Hollowing (Tiến trình rỗng)

**Process Hollowing** (còn gọi là RunPE) là kỹ thuật injection cho phép **chạy mã độc trong vỏ bọc của một tiến trình hợp pháp**. Cách thực hiện gồm nhiều bước như sau:

1. **Tạo tiến trình “mồi” ở trạng thái suspended**: Malware sẽ khởi động một tiến trình Windows hợp pháp (ví dụ: `svchost.exe`, `notepad.exe`) nhưng với cờ `CREATE_SUSPENDED` để tiến trình tạm dừng ngay từ đầu ([MITRE ATT&CK T1055.012 Process Injection: Process Hollowing](https://www.picussecurity.com/resource/blog/t1055-012-process-hollowing#:~:text=1,the%20CREATE_SUSPEND%20option%20used%20in)). Tiến trình này đóng vai trò “vỏ bọc” – có tên và path hợp lệ, được hệ thống tin tưởng.

2. **Rỗng hóa không gian tiến trình**: Tiếp theo, malware **unmap** (giải phóng) vùng nhớ chứa image của tiến trình hợp pháp vừa tạo. Nói cách khác, nó **loại bỏ toàn bộ mã hợp pháp của notepad/svchost** khỏi bộ nhớ, tạo khoảng trống để nhét mã độc vào ([MITRE ATT&CK T1055.012 Process Injection: Process Hollowing](https://www.picussecurity.com/resource/blog/t1055-012-process-hollowing#:~:text=Process%20Hollowing%20is%20a%20process,context%20of%20the%20target%20process)). Việc unmap có thể thực hiện bằng API Native như `NtUnmapViewOfSection`.

3. **Inject mã độc vào tiến trình rỗng**: Malware **cấp phát bộ nhớ** trong tiến trình suspended đó đủ lớn cho payload (có thể là một PE EXE hoặc DLL), rồi **ghi mã độc** của nó vào (thường sử dụng `WriteProcessMemory`). Nếu payload là một PE (EXE), malware sẽ **điều chỉnh Entry Point** và các thông số context thread chính trỏ tới địa chỉ mới chứa mã độc.

4. **Khôi phục và chạy tiến trình**: Cuối cùng, malware **resume** luồng chính của tiến trình. Do image hợp pháp đã bị thay bằng mã độc, nên khi tiếp tục, tiến trình sẽ **nhảy vào thực thi mã độc ngay trong ngữ cảnh tiến trình hợp pháp** đó.

Kết quả là mã độc “ký sinh” bên trong tiến trình Windows đáng tin cậy. Từ góc nhìn của hệ thống, vẫn có một tiến trình mang tên hợp pháp đang chạy, PID, path không đổi, nhưng **bên trong bộ nhớ, code đã bị thay thế hoàn toàn** bằng payload của attacker ([MITRE ATT&CK T1055.012 Process Injection: Process Hollowing](https://www.picussecurity.com/resource/blog/t1055-012-process-hollowing#:~:text=Process%20hollowing%20is%20a%20technique,visible%20to%20the%20operating%20system)). Điều này giúp malware **ẩn mình hiệu quả**: công cụ giám sát thông thường thấy `notepad.exe` chạy sẽ ít nghi ngờ, và quá trình scanning tệp tin cũng không phát hiện gì vì file notepad.exe trên đĩa vẫn nguyên vẹn. Mã độc chạy với quyền của tiến trình đó, có thể tận dụng **quyền hạn và tài nguyên** của nó như một quá trình tin cậy. Process hollowing chủ yếu nhằm **né tránh các cơ chế bảo vệ dựa trên danh tính tiến trình**: ví dụ phần mềm nào chỉ cho phép một số tiến trình nhất định truy cập tài nguyên nhạy cảm. Ngoài ra, vì **mã gốc của tiến trình hợp pháp đã bị gỡ khỏi bộ nhớ**, công cụ debugging hay dump memory thông thường cũng khó phân biệt được có bất thường, trừ khi so sánh nội dung bộ nhớ với file gốc trên đĩa. Kỹ thuật này phổ biến trong nhiều mã độc (ví dụ trojan ngân hàng, ransomware) để ẩn tiến trình độc hại dưới tên một tiến trình hệ thống nhằm **trì hoãn bị phát hiện càng lâu càng tốt** ([MITRE ATT&CK T1055.012 Process Injection: Process Hollowing](https://www.picussecurity.com/resource/blog/t1055-012-process-hollowing#:~:text=Process%20hollowing%20is%20a%20technique,visible%20to%20the%20operating%20system)).

### 2.5. Bypass hooking (Vô hiệu hóa cơ chế hook giám sát)

Kỹ thuật **hooking bypass** tập trung vào việc **vô hiệu hóa hoặc né tránh các cơ chế giám sát mà Windows Defender/EDR cài cắm vào hệ thống**. Kẻ tấn công có thể dùng nhiều thủ đoạn tinh vi để làm **mù** hệ thống phòng thủ:

- **Unhooking DLL**: Nhiều EDR inject chính *DLL của chúng* vào mọi tiến trình (ví dụ DLL giám sát của EDR) và **đặt hook** vào các API quan trọng. Do các hook này thường nằm trong các module như ntdll.dll ở tiến trình, malware có thể thực hiện “unhook” bằng cách **khôi phục lại module gốc sạch sẽ**. Cách làm phổ biến là tải một bản `ntdll.dll` sạch từ đĩa (hoặc từ memory của chính tiến trình) vào một vùng nhớ khác, sau đó **ghi đè các đoạn mã đã bị hook bằng bản gốc**. Kết quả là **toàn bộ hook của EDR bị gỡ bỏ**, EDR không còn chặn hay theo dõi được các lời gọi API nữa ([3 EDR Bypass Techniques & How to Stop Them | Deep Instinct](https://www.deepinstinct.com/blog/edr-bypass-techniques-and-how-to-stop-them#:~:text=Unhooking%20refers%20to%20a%20method,for%20any%20API%20calls%20made)). Lúc này, malware có thể thoải mái gọi API như CreateRemoteThread, VirtualAllocEx… mà không bị chuyển hướng vào code bảo vệ của EDR. Nghiên cứu cho thấy sau khi unhook, EDR gần như "bịt mắt" trước các hoạt động của malware trong tiến trình ([3 EDR Bypass Techniques & How to Stop Them | Deep Instinct](https://www.deepinstinct.com/blog/edr-bypass-techniques-and-how-to-stop-them#:~:text=Unhooking%20refers%20to%20a%20method,for%20any%20API%20calls%20made)). Kỹ thuật này thường được tích hợp sẵn trong các kit tấn công (ví dụ Metasploit, Cobalt Strike đều có chức năng “Sleep Unhook” để gỡ hook các hàm WinAPI trước khi thực thi payload).

- **Vô hiệu hóa ETW và AMSI**: Bên cạnh hooking API, Windows Defender và nhiều EDR hiện đại sử dụng **Event Tracing for Windows (ETW)** để thu thập log hành vi và **AMSI** để quét nội dung độc hại trong script hoặc bộ nhớ. Do đó, malware tìm cách **tắt các “cảm biến” này**. Ví dụ, mã độc của nhóm APT41, chiến dịch Slingshot, ransomware LockerGoga... đều từng **disable ETW** nhằm tránh bị EDR ghi lại dấu vết ([New ETW Attacks Can Allow Hackers to 'Blind' Security Products - SecurityWeek](https://www.securityweek.com/new-etw-attacks-can-allow-hackers-blind-security-products/#:~:text=Threat%20actors%2C%20including%20profit,campaign%2C%20and%20the%20LockerGoga%20ransomware)). Kỹ thuật cụ thể thường là tìm tới hàm `EtwEventWrite` trong ntdll.dll (hàm dùng ghi log ETW) và patch nó để luôn trả về lỗi hoặc không làm gì (NOP), khiến **mọi sự kiện bảo mật mà EDR chờ đợi không được gửi đi**. Tương tự, malware có thể patch các hàm AMSI (như `AmsiScanBuffer`) để **chặn Defender quét payload trong bộ nhớ**, qua mặt được việc kiểm tra script PowerShell hoặc macro độc hại. Những **AMSI bypass** như vậy đã trở nên phổ biến trên các kho mã tấn công.

- **Tránh tạo hành vi nghi vấn**: Một số malware cố gắng **đi đường vòng để không bị hook** ngay từ đầu. Thay vì gọi trực tiếp API thường bị giám sát, chúng dùng kỹ thuật “**shellcode stagers**” gọi các syscall thấp hoặc dùng hàm ít phổ biến hơn để đạt mục đích tương tự. Ví dụ, thay vì CreateRemoteThread, malware có thể dùng **QueueUserAPC** hoặc **NtCreateThreadEx**; thay vì WriteProcessMemory, có thể map một file vào tiến trình đích (Section Mapping) để đưa payload vào. Những con đường ít được theo dõi có thể **né bẫy hook** của Defender. Thậm chí, có trường hợp malware tận dụng **chính sách hạn chế** của hệ thống để vô hiệu EDR: như kỹ thuật “**PPID Spoofing + PPL**” – tạo tiến trình con dưới danh nghĩa tiến trình quan trọng (như LSASS) ở chế độ Protected Process, khiến EDR **không dám inject DLL giám sát** vào tiến trình đó do vi phạm bảo vệ.

Tóm lại, **hooking bypass** bao gồm mọi cách thức để malware **vượt qua lớp giám sát của Defender/EDR**, từ thao túng bộ nhớ (patch/unhook) đến lợi dụng thiết kế (tắt ETW) hay chọn con đường ít ai ngờ. Đây là nhóm kỹ thuật phức tạp nhưng mang lại hiệu quả cao: nếu thành công, malware sẽ **hoạt động “dưới radar”** mà các hệ thống bảo mật không hay biết.

### 2.6. Mã hóa & encode payload (Encryption & Encoding)

Để tránh bị phát hiện bởi antivirus khi lưu trữ hoặc tải payload DLL, malware hầu như luôn **mã hóa hoặc mã hóa theo dạng encode** nội dung độc hại của mình. Mục tiêu là làm cho **chuỗi byte của payload không khớp với signature mẫu** mà các chương trình diệt virus có thể nhận ra. Các kỹ thuật thường thấy gồm:

- **Mã hóa (Encryption)**: Payload (có thể là DLL hoặc shellcode) được mã hóa bằng thuật toán (ví dụ AES, RC4, XOR đa byte) cùng với một khóa bí mật. Payload sau mã hóa trông như dữ liệu ngẫu nhiên, **các mẫu chuỗi, opcode đặc trưng bị ẩn đi hoàn toàn** ([MALWARE DETECTION : EVASION TECHNIQUES - CYFIRMA](https://www.cyfirma.com/outofband/malware-detection-evasion-techniques/#:~:text=malware%E2%80%99s%20content%20into%20a%20scrambled,is%20hidden%20within%20the%20encrypted)). Antivirus dựa trên chữ ký sẽ khó phát hiện vì **phần nội dung độc hại đã bị “xáo trộn”** và chỉ có thể được giải mã với khóa đúng. Mã độc chỉ giải mã payload **ngay trước khi thực thi trong bộ nhớ**, do đó cửa sổ để AV kịp quét được nội dung thật rất ngắn. Microsoft cho biết cơ chế quét dựa trên signature sẽ kém hiệu quả rõ rệt trước malware đã mã hóa, bởi **chữ ký nằm ẩn bên trong nội dung đã mã hóa** ([MALWARE DETECTION : EVASION TECHNIQUES - CYFIRMA](https://www.cyfirma.com/outofband/malware-detection-evasion-techniques/#:~:text=malware%E2%80%99s%20content%20into%20a%20scrambled,is%20hidden%20within%20the%20encrypted)).

- **Đóng gói (Packing) và Crypter**: Nhiều malware dùng **packers/crypters** – là những chương trình “vỏ bọc” có nhiệm vụ nén và/hoặc mã hóa malware gốc. Packer sẽ tạo ra một **file thực thi mới** chứa payload đã mã hóa kèm theo **routine giải nén/giải mã** ([MALWARE DETECTION : EVASION TECHNIQUES - CYFIRMA](https://www.cyfirma.com/outofband/malware-detection-evasion-techniques/#:~:text=Packers%20and%20Crypters%3A%20Packers%20and,changing%20versions)). Khi file này chạy, routine sẽ **mở khóa payload trong bộ nhớ** rồi chuyển quyền điều khiển sang mã độc thật. Kỹ thuật này không chỉ ẩn mã độc khỏi static scan, mà còn có thể **thay đổi payload liên tục (polymorphic)** – mỗi lần pack sẽ ra một file khác nhau về byte sequence. Kết quả là **mã độc luôn biến đổi** và **tránh bị nhận dạng** bởi chữ ký tĩnh ([MALWARE DETECTION : EVASION TECHNIQUES - CYFIRMA](https://www.cyfirma.com/outofband/malware-detection-evasion-techniques/#:~:text=obfuscation%20makes%20it%20difficult%20for,to%20recognize%20their%20malicious%20activities)). Nhiều dòng trojan, ransomware dùng crypter thuê bao: mỗi ngày tạo ra biến thể mã hóa mới, buộc các sản phẩm AV phải chạy phân tích hành vi thay vì dựa vào mẫu hash hay chuỗi tĩnh.

- **Encoding đơn giản**: Bên cạnh mã hóa mạnh, malware có thể dùng các encode giản đơn như **Base64, Hex, XOR 1 byte** để giấu payload hoặc string. Ví dụ, một DLL malware có thể lưu các string API, tên tiến trình, IP C2 dưới dạng base64 để tránh bị phát hiện bởi rule AV tìm chuỗi đáng ngờ. Mặc dù các encoding này có thể dễ dàng bị đảo ngược, chúng đủ để **tránh các bộ lọc chữ ký đơn giản**. Đối với shellcode, kỹ thuật **shikata ga nai** (trong Metasploit) là một encoder nổi tiếng, XOR mã lệnh nhiều vòng kèm theo bộ giải mã tự triển khai – giúp shellcode **tránh bị dò mẫu byte độc hại**.

Nhờ **mã hóa và encode**, DLL Injection có thể thực hiện mà **payload không bị lộ dạng** cho đến thời điểm thi hành thực sự. Điều này thách thức các giải pháp bảo mật: thay vì phát hiện từ sớm bằng signature, họ buộc phải để ý các hành vi nghi vấn (như tiến trình nào đó tự giải mã một khối lớn dữ liệu rồi thực thi) hoặc dùng cơ chế **giải mã và phân tích trong môi trường cách ly**. Ngày nay, hầu hết các *loader* (trình nạp) DLL độc hại đều tích hợp sẵn một lớp mã hóa/độn mã cho payload để **qua mắt antivirus và EDR** tối đa.

## 3. Cách hoạt động của các cơ chế phát hiện (Windows Defender, EDR)

Trong môi trường doanh nghiệp, các giải pháp như **Windows Defender Antivirus/ATP** (nay là Microsoft Defender for Endpoint) và các sản phẩm **Endpoint Detection & Response (EDR)** đóng vai trò tuyến cuối, phát hiện và chặn hành vi DLL Injection nếu nó xảy ra. Hiểu cách những cơ chế này hoạt động giúp chúng ta triển khai phòng thủ hiệu quả hơn.

### Cơ chế phát hiện của EDR và Windows Defender Antivirus

Các sản phẩm EDR/AV hiện đại kết hợp **nhiều phương pháp giám sát** để phát hiện hành vi **process injection/DLL injection**:

- **Hooking và giám sát API**: Như đã đề cập, Defender và EDR cài **hook vào các API nhạy cảm** (CreateRemoteThread, VirtualAllocEx, WriteProcessMemory, QueueUserAPC, SetThreadContext, v.v.) để **theo dõi mọi lời gọi từ các tiến trình**. Khi một tiến trình gọi các hàm này, mã giám sát của EDR sẽ kiểm tra xem nguồn và đích của thao tác có bất thường không (ví dụ: một tiến trình user-mode đột nhiên viết memory vào tiến trình của hệ thống hoặc chèn thread vào tiến trình khác). Nhờ hooking, **EDR quan sát được hầu hết các bước của chuỗi injection** – cấp phát bộ nhớ, ghi payload, thực thi – và có thể chặn lại trước khi payload kịp chạy. Tuy nhiên, như đã thảo luận, kỹ thuật direct syscalls và unhooking có thể vô hiệu hóa dạng giám sát này.

- **Phân tích chuỗi hành vi (behavioral analytics)**: EDR không chỉ nhìn từng API rời rạc, mà còn **phân tích chuỗi sự kiện**. Ví dụ, **trình tự**: một tiến trình gọi `OpenProcess` (mở handle tới tiến trình khác) → rồi `VirtualAllocEx` → `WriteProcessMemory` → `CreateRemoteThread` gần như chắc chắn là **một vụ code injection**. EDR sẽ cộng gộp các sự kiện liên tiếp này và so khớp với mẫu tấn công đã biết. Nhiều EDR áp dụng mô hình trạng thái cho kỹ thuật injection: *Allocate memory* + *Write code* + *Execute thread*. Bất kể malware dùng API cụ thể nào, nếu chúng đạt đủ ba bước “cấp phát – ghi – thực thi” trong tiến trình khác, EDR có thể nhận diện đó là hành vi đáng ngờ ([Detecting Process Injection - by Adeem Mawani](https://blog.blacklanternsecurity.com/p/detecting-process-injection#:~:text=With%20the%20myriad%20of%20publicly,that%20we%20can%20potentially%20identify)). Cách tiếp cận này giúp bắt được cả biến thể injection lạ (hollowing, doppelgänging…) vì chúng đều phải tuân theo nguyên lý chung.

- **Giám sát kernel và sự kiện hệ thống**: Do user-mode hooking có thể bị né tránh, các giải pháp tiên tiến bổ sung **cơ chế giám sát ở tầng kernel hoặc qua cơ chế event tracing**. Windows cung cấp các callback kernel (ví dụ: **PsCreateThreadNotifyRoutine** để báo khi có thread được tạo, **PsSetLoadImageNotifyRoutine** khi có module được load) – EDR có driver kernel có thể đăng ký những callback này. Nhờ đó, nếu malware dùng syscalls để tạo remote thread, driver kernel của EDR vẫn có thể **phát hiện một thread xuất hiện trong tiến trình đích** và kiểm tra nguồn gốc của nó. Tương tự, sự kiện **Image Load** có thể phát hiện một DLL lạ được map vào tiến trình (dù reflective injection không tạo file, nhưng nếu DLL được map với Section, vẫn có event). Ngoài ra, EDR tận dụng **ETW**: nhiều sản phẩm endpoint cấu hình **ETW providers** cho sự kiện như “Remote Thread Creation”, “Process Hollowing attempt” và thu thập log gần real-time. Dữ liệu này kết hợp với máy học hoặc luật định trước trên cloud của EDR để xác định mối đe dọa.

- **Quét bộ nhớ và so sánh**: Một số EDR và Defender Antivirus triển khai **quét mẫu trong bộ nhớ (memory scanning)** để phát hiện payload DLL/shellcode ngay cả khi file không tồn tại trên đĩa. Microsoft Defender có tích hợp AMSI cho các tiến trình script và cả kỹ thuật **scan định kỳ vùng nhớ** tìm shellcode của các trojan thường gặp. Ví dụ, khi một tiến trình vừa tạo vùng nhớ thực thi (PAGE_EXECUTE_READWRITE) và ghi dữ liệu vào đó, Defender AV có thể tạm dừng luồng thực thi và **quét vùng nhớ đó** xem có byte pattern khớp mã độc đã biết hay không. Chính nhờ cơ chế này, Defender đã phát hiện nhiều mẫu Meterpreter, Cobalt Strike beacon dù chúng chạy hoàn toàn trong memory.

- **Phân tích hành vi bất thường khác**: EDR còn giám sát các dấu hiệu gián tiếp: tiến trình nào bỗng nhiên **tăng mức sử dụng CPU** hoặc **dùng nhiều network** ngay sau khi bị inject, tiến trình văn phòng (Word, Excel) mà lại gọi các hàm dính dáng đến thực thi (VirtualAlloc, COM object thực thi) – từ đó kích hoạt cảnh báo sớm. Một ví dụ: EDR có thể đánh dấu nếu thấy tiến trình Office cố gắng thực hiện hành vi injection, nhờ đó chặn được macro malware ngay lập tức ([Attack surface reduction rules reference - Microsoft Defender for Endpoint | Microsoft Learn](https://learn.microsoft.com/en-us/defender-endpoint/attack-surface-reduction-rules-reference#:~:text=Block%20Office%20applications%20from%20creating,USB%20Audit%20or%20Block%20Y)).

Nhìn chung, Windows Defender AV và EDR ngày nay dựa vào **phân tích hành vi thời gian thực** và **đa tầng giám sát** để phát hiện DLL Injection. Defender Antivirus truyền thống có thể bỏ lọt mã độc fileless, nhưng khi kết hợp với **Defender for Endpoint (ATP)**, Microsoft cung cấp khả năng theo dõi rất sát các kỹ thuật như reflective DLL, process hollowing, APC injection, v.v. và phản ứng tự động.

### Windows Defender ATP giám sát DLL Injection như thế nào?

**Windows Defender Advanced Threat Protection (ATP)** – nay là Microsoft Defender for Endpoint – là hệ thống EDR của Microsoft tích hợp sâu với Windows 10/11. Trong các bản cập nhật lớn (Windows 10 Creators Update trở đi), Microsoft đã bổ sung nhiều cải tiến để ATP nhận diện tốt hơn kỹ thuật **cross-process injection**. Cụ thể, **Defender ATP instrument (theo dõi) các hàm liên quan đến injection ở mức độ hệ thống** và đưa ra mô hình máy học để phát hiện hành vi bất thường ([Uncovering cross-process injection with Windows Defender ATP | Microsoft Security Blog](https://www.microsoft.com/en-us/security/blog/2017/03/08/uncovering-cross-process-injection-with-windows-defender-atp/#:~:text=Instrumentation%20and%20detection%20in%20Windows,Defender%20ATP)). Điều này có nghĩa là Windows Defender ATP ghi lại việc sử dụng các API như CreateRemoteThread, QueueUserAPC, NtMapViewOfSection, SetThreadContext... trên toàn hệ thống, sau đó dùng thuật toán để phân biệt đâu là hợp lệ, đâu là dấu hiệu tấn công.

Microsoft đã trình bày khả năng phát hiện này qua ví dụ thực tế:

- **Phát hiện CreateRemoteThread (Gatak malware)**: Một biến thể malware Gatak tiêm DLL vào **rundll32.exe** bằng cách tạo remote thread. Nó tạo process rundll32, dùng `VirtualAllocEx` cấp phát bộ nhớ, `WriteProcessMemory` ghi payload, rồi gọi `CreateRemoteThread` thực thi payload và tự xóa file trên đĩa (fileless) ([Uncovering cross-process injection with Windows Defender ATP | Microsoft Security Blog](https://www.microsoft.com/en-us/security/blog/2017/03/08/uncovering-cross-process-injection-with-windows-defender-atp/#:~:text=As%20a%20user%20launches%20a,servers%2C%20giving%20GOLD%20attackers)). Với cải tiến của Windows 10, **Defender ATP ngay lập tức phát hiện chuỗi hành động cross-process injection này** và kích hoạt cảnh báo về hành vi tiêm mã vào tiến trình khác ([Uncovering cross-process injection with Windows Defender ATP | Microsoft Security Blog](https://www.microsoft.com/en-us/security/blog/2017/03/08/uncovering-cross-process-injection-with-windows-defender-atp/#:~:text=With%20Creators%20Update%2C%20Windows%20Defender,Defender%20ATP%20Creators%20Update%20portal)). Trên giao diện ATP portal, quản trị viên sẽ thấy alert chi tiết và tiến trình rundll32.exe bị đánh dấu là bị inject.

- **Phát hiện QueueUserAPC (Fynloski RAT)**: Một RAT cũ sử dụng **QueueUserAPC** để thực hiện injection (APC injection). Thay vì tạo thread mới, nó viết shellcode vào tiến trình đích rồi dùng `QueueUserAPC` gắn thực thi shellcode đó vào thread có sẵn của tiến trình mục tiêu. Kỹ thuật này tinh vi hơn, nhưng **Defender ATP đã instrument hàm QueueUserAPC** – do ít khi được dùng trong ngữ cảnh bình thường – nên khi RAT gọi API này để trỏ đến địa chỉ code vừa ghi, ATP xác định hành vi đáng ngờ. Kết quả, **ATP ra cảnh báo cùng timeline chi tiết về việc tiến trình gọi QueueUserAPC bất thường** ([Uncovering cross-process injection with Windows Defender ATP | Microsoft Security Blog](https://www.microsoft.com/en-us/security/blog/2017/03/08/uncovering-cross-process-injection-with-windows-defender-atp/#:~:text=Instead%20of%20using%20the%20more,QueueUserAPC%20to%20execute%20this%20code)).

- **Phát hiện SetThreadContext (CoinMiner)**: Một malware đào tiền ảo dùng kỹ thuật **hijack thread** – nó lấy snapshot thread của tiến trình đích, dùng `SetThreadContext` để đổi luồng đó trỏ vào code độc trong memory. Đây là biến thể của process hollowing (Atom Bombing hoặc Thread Context injection). Windows Defender ATP cũng đã bổ sung rule cho hành vi này, nên khi CoinMiner thực thi, ATP ghi nhận chuỗi: OpenProcess → SuspendThread → SetThreadContext → ResumeThread, liền cảnh báo hành vi hollowing.

Những ví dụ trên cho thấy **Windows Defender ATP theo dõi hầu hết các vector injection** và có khả năng **phát hiện cả kỹ thuật tinh vi**. Quan trọng hơn, ATP cung cấp thông tin điều tra: tiến trình nào inject, inject vào đâu, chuỗi API nào được gọi theo thứ tự. Điều này rất hữu ích cho đội ngũ phản ứng sự cố (IR) trong doanh nghiệp, giúp họ **khoanh vùng ngay tiến trình bị xâm nhập** và malware gốc.

### Biện pháp bảo mật nâng cao ngăn chặn DLL Injection trong doanh nghiệp

Để **phòng thủ vững chắc ở cấp độ doanh nghiệp**, ngoài việc hiểu và cấu hình các công cụ sẵn có, cần triển khai thêm những biện pháp nâng cao:

- **Triển khai giải pháp EDR toàn diện**: Đảm bảo mọi máy trạm và server trong doanh nghiệp đều cài đặt EDR (như Microsoft Defender for Endpoint hoặc các hãng khác) và kích hoạt đầy đủ tính năng. EDR nên được cấu hình để **chặn tự động** các hành vi injection đã biết (theo khuyến cáo của nhà cung cấp). Thêm vào đó, sử dụng tính năng **cloud-analysis**: khi phát hiện nghi vấn, gửi dữ liệu lên cloud AI của hãng để phân tích nâng cao (nhiều EDR có sandbox cloud để phân tích hành vi tiến trình). Điều này giúp bắt được các mẫu zero-day sử dụng kỹ thuật injection mới.

- **Tăng cường chính sách Application Control**: Ngoài AppLocker/WDAC cho máy trạm, với các máy chủ quan trọng, hãy thực hiện **code signing enforcement** nghiêm ngặt. Chỉ cho phép chạy ứng dụng và DLL được công ty phê duyệt (có chữ ký số công ty hoặc của Microsoft). Bất kỳ DLL nào lạ, không có trong danh sách, đều bị chặn. Chính sách whitelisting tốt sẽ làm cho **DLL độc hại không có cơ hội được nạp** ngay cả khi malware cố injection ([windows - Prevent Process Hijacking and injection? - Information Security Stack Exchange](https://security.stackexchange.com/questions/161861/prevent-process-hijacking-and-injection#:~:text=or%20DLLs)). Mặc dù cách này yêu cầu vận hành và duy trì (cập nhật whitelist khi có phần mềm mới), nhưng hiệu quả bảo vệ rất cao.

- **Giám sát chủ động với Sysmon + SIEM**: Triển khai Sysmon trên toàn bộ endpoint với cấu hình tùy chỉnh để log các event injection (Event ID 8 - CreateRemoteThread, Event ID 7 - Image loaded bất thường từ thư mục user, Event ID 10 - ProcessAccess mở handle injection,...). Tích hợp log này về hệ thống SIEM tập trung. Đội ngũ SOC nên thiết lập **quy tắc cảnh báo** khi thấy các sự kiện như *Process Injection detected* hoặc *image load từ đường dẫn không tin cậy*. Ví dụ, nếu Sysmon báo tiến trình Word mở handle và viết memory vào tiến trình con *eqnedt32.exe* (một dấu hiệu DLL sideloading), SOC sẽ nhận được alert sớm. Cách làm này hỗ trợ EDR và đôi khi phát hiện cả những gì EDR bỏ lọt.

- **Bảo vệ EDR khỏi bị bypass**: Kẻ tấn công ngày càng có kỹ thuật vượt qua EDR (như unhooking). Vì vậy, các doanh nghiệp nên chọn giải pháp EDR có cơ chế **tự bảo vệ**. Ví dụ, một số EDR tiên tiến theo dõi cả **sự toàn vẹn của vùng nhớ hook** – nếu có tiến trình nào cố sửa đổi byte code trong ntdll.dll nơi EDR đặt hook, EDR sẽ phát hiện và phản ứng ([3 EDR Bypass Techniques & How to Stop Them | Deep Instinct](https://www.deepinstinct.com/blog/edr-bypass-techniques-and-how-to-stop-them#:~:text=match%20at%20L859%20Just%20as,these%20memory%20areas%20are%20deemed)). Deep Instinct cho biết sản phẩm của họ giám sát các vùng memory đã hook, bất kỳ truy cập ghi nào đều bị chặn như hành vi tấn công ([3 EDR Bypass Techniques & How to Stop Them | Deep Instinct](https://www.deepinstinct.com/blog/edr-bypass-techniques-and-how-to-stop-them#:~:text=match%20at%20L859%20Just%20as,these%20memory%20areas%20are%20deemed)). Các tính năng “EDR self-defense” như vậy rất quan trọng, đảm bảo **malware không dễ dàng vô hiệu hóa lớp bảo vệ**.

- **Cập nhật hệ điều hành và bật bảo mật nền tảng**: Luôn cập nhật bản vá Windows, bởi Microsoft thường xuyên bổ sung các **biện pháp chống khai thác và chống injection** mới. Ví dụ, Windows 10 có tính năng **Credential Guard** dựa trên ảo hóa để bảo vệ nhân (kernel) và tiến trình LSASS, ngăn truy cập và inject trái phép vào LSASS. Bật **Memory Integrity (HVCI)** để chỉ cho phép driver kernel đã ký và tránh malware cài driver để hỗ trợ injection ở mức kernel. Sử dụng **Protected Process Light** cho dịch vụ quan trọng (như antivirus) để malware không thể can thiệp. Những biện pháp nền tảng này tạo tầng phòng thủ vững chắc, giảm bề mặt tấn công cho kỹ thuật DLL Injection.

- **Đào tạo nhận thức và kiểm soát đầu vào**: Cuối cùng, cần nhớ rằng DLL Injection thường là **bước hậu khai thác** – tức malware phải xâm nhập được vào hệ thống (qua lừa đảo, khai thác lỗ hổng, cài được mã thực thi) rồi mới dùng injection để ẩn mình. Do đó, việc **đào tạo người dùng** tránh bấm vào file không rõ nguồn gốc, **vá các lỗ hổng ứng dụng** (nhất là ứng dụng Office, PDF reader, trình duyệt) sẽ khiến kẻ tấn công khó có cơ hội thực thi bước injection. Triển khai cơ chế cách ly (VDI, Sandbox cho các file văn phòng từ ngoài) cũng hạn chế kịch bản malware nội bộ. Một khi chúng ta giảm thiểu được sự xâm nhập ban đầu, nguy cơ DLL Injection xảy ra trong hệ thống cũng giảm theo.

**Tổng kết:** DLL Injection là kỹ thuật nguy hiểm giúp mã độc **ẩn náu bên trong tiến trình hợp pháp** để qua mặt an ninh. Để đối phó, quản trị viên cần kết hợp **các biện pháp phòng thủ nhiều lớp**: từ cấu hình công cụ giám sát (Sysmon, Process Explorer, PE-sieve) để phát hiện sớm, đến thiết lập chặt chẽ Windows Defender/EDR và chính sách whitelisting để ngăn chặn. Đồng thời, phải hiểu rõ các **mánh khóe injection** (obfuscation, direct syscalls, reflective DLL, hollowing, hooking bypass, encoding…) mà kẻ tấn công sử dụng, từ đó kiểm tra và tăng cường hệ thống cho phù hợp. Các cơ chế phát hiện như Windows Defender ATP và EDR ngày càng tinh vi, có thể nhận diện hầu hết kỹ thuật injection phổ biến ([Uncovering cross-process injection with Windows Defender ATP | Microsoft Security Blog](https://www.microsoft.com/en-us/security/blog/2017/03/08/uncovering-cross-process-injection-with-windows-defender-atp/#:~:text=Instead%20of%20using%20the%20more,QueueUserAPC%20to%20execute%20this%20code)), tuy nhiên chúng cũng có giới hạn nếu cấu hình sai hoặc gặp biến thể mới. Do đó, việc **cập nhật thông tin tấn công, thử nghiệm tấn công giả lập (pentest/red team)** để kiểm tra hiệu quả phòng thủ là rất cần thiết. Với cách tiếp cận nhiều lớp và chủ động như trên, doanh nghiệp có thể **giảm thiểu đáng kể nguy cơ** bị tấn công thành công bằng DLL Injection. 

**Nguồn tham khảo:**

1. MITRE ATT&CK – *Dynamic-link Library Injection (T1055.001)* ([Process Injection: Dynamic-link Library Injection, Sub-technique T1055.001 - Enterprise | MITRE ATT&CK®](https://attack.mitre.org/techniques/T1055/001/#:~:text=Running%20code%20in%20the%20context,masked%20under%20a%20legitimate%20process))

2. LetsDefend – *Process Injection Detection with Sysmon* (Ví dụ Sysmon Event ID 8 bắt được injection) ([Process Injection Detection with Sysmon](https://letsdefend.io/blog/process-injection-detection-with-sysmon#:~:text=))

3. Shellcode.blog – *Sysmon’s Ability to Detect Process Injections* (Lưu ý cần cấu hình Sysmon đúng để không bỏ sót sự kiện CreateRemoteThread) ([Studying Sysmon's Ability to Detect Process Injections Using Different Configuration Schemas – Shellcode.Blog – Personal Computer Security Blog.](https://shellcode.blog/Studying_Sysmon_Ability_to_Detect_Process_Injections/#:~:text=Sysmon%20is%20a%20very%20helpful,identifier%20for%20a%20CreateRemoteThread%20event))

4. Microsoft Docs – *Using Process Explorer to list DLLs* (Hướng dẫn dùng Process Explorer liệt kê DLL và lọc DLL bên thứ ba) ([Using Process Explorer to list dlls running under Outlook.exe - Outlook | Microsoft Learn](https://learn.microsoft.com/en-us/outlook/troubleshoot/performance/using-process-explorer-to-list-dlls-running-under-outlook-exe#:~:text=Analyzing%20the%20Process%20Explorer%20Output))

5. Hasherezade Blog – *PE-sieve* (Công cụ phát hiện PE/DLL được tiêm, hollowing, reflective injection…) ([PE-sieve: PE-sieve](https://hasherezade.github.io/pe-sieve/index.html#:~:text=PE,Doppelg%C3%A4nging%2C%20Reflective%20DLL%20Injection%2C%20etc)) ([PE-sieve: PE-sieve](https://hasherezade.github.io/pe-sieve/index.html#:~:text=Recognizes%20and%20dumps%20variety%20of,Doppelg%C3%A4nging%2C%20Reflective%20DLL%20Injection%2C%20etc))

6. Microsoft Learn – *Attack Surface Reduction rules* (Quy tắc chặn ứng dụng Office tiêm mã vào tiến trình khác) ([Attack surface reduction rules reference - Microsoft Defender for Endpoint | Microsoft Learn](https://learn.microsoft.com/en-us/defender-endpoint/attack-surface-reduction-rules-reference#:~:text=Block%20Office%20applications%20from%20creating,USB%20Audit%20or%20Block%20Y))

7. Security.Stackexchange – *Prevent Process Hijacking and Injection* (Khuyến nghị dùng AppLocker whitelist để chặn DLL Injection) ([windows - Prevent Process Hijacking and injection? - Information Security Stack Exchange](https://security.stackexchange.com/questions/161861/prevent-process-hijacking-and-injection#:~:text=or%20DLLs))

8. Apriorit – *Mitigate DLL Injection Attacks* (Đề xuất kiểm tra chữ ký số DLL và thư mục tin cậy trước khi cho LoadLibrary) ([Mitigate DLL Injection Attacks - Apriorit](https://www.apriorit.com/dev-blog/secure-windows-software-against-dll-attacks#:~:text=To%20determine%20that%20a%20DLL,or%20vendor%20and%20source%20validation))

9. CYFIRMA – *Malware Evasion Techniques* (Mô tả polymorphic/metamorphic malware thay đổi mã để né signature) ([MALWARE DETECTION : EVASION TECHNIQUES - CYFIRMA](https://www.cyfirma.com/outofband/malware-detection-evasion-techniques/#:~:text=Polymorphic%20and%20Metamorphic%20Malware%3A%20Polymorphic,underlying%20code%20while%20maintaining%20its))

10. CYFIRMA – *Malware Evasion Techniques* (Mã hóa payload che giấu nội dung, signature AV kém hiệu quả) ([MALWARE DETECTION : EVASION TECHNIQUES - CYFIRMA](https://www.cyfirma.com/outofband/malware-detection-evasion-techniques/#:~:text=malware%E2%80%99s%20content%20into%20a%20scrambled,is%20hidden%20within%20the%20encrypted))

11. CYFIRMA – *Malware Evasion Techniques* (Kỹ thuật packer/crypter nén và mã hóa mã độc, giải mã payload khi chạy) ([MALWARE DETECTION : EVASION TECHNIQUES - CYFIRMA](https://www.cyfirma.com/outofband/malware-detection-evasion-techniques/#:~:text=Packers%20and%20Crypters%3A%20Packers%20and,changing%20versions))

12. PwnedCoffee – *Bypassing Antivirus using Direct System Calls* (Cơ chế hook API của EDR qua ntdll.dll) ([AV/EDR Bypass Using Direct Syscalls - Red Team Tactics - PwnedC0ffee](https://pwnedcoffee.com/blog/bypassing-antivirus-using-direct-system-calls/#:~:text=)) ([AV/EDR Bypass Using Direct Syscalls - Red Team Tactics - PwnedC0ffee](https://pwnedcoffee.com/blog/bypassing-antivirus-using-direct-system-calls/#:~:text=The%20Native%20API%20%28NTDLL,DLL))

13. PassTheHashBrowns – *Detecting Direct Syscalls* (Giải thích direct syscall khiến EDR userland **mù** vì chuyển thẳng vào kernel) ([Detecting Direct Syscalls with Frida | PassTheHashBrowns](https://passthehashbrowns.github.io/detecting-direct-syscalls-with-frida#:~:text=EDR%20products%20were%20largely%20forced,userland%20hooking%20will%20be%20blind))

14. Ired.team – *Reflective DLL Injection* (Định nghĩa kỹ thuật nạp DLL từ bộ nhớ thay vì từ đĩa) ([Reflective DLL Injection | Red Team Notes](https://www.ired.team/offensive-security/code-injection-process-injection/reflective-dll-injection#:~:text=Loading%20DLL%20from%20memory))

15. Microsoft Learn – *AMSI & fileless malware* (Mô tả Reflective DLL injection nạp DLL vào bộ nhớ, né cơ chế theo dõi module của OS) ([Anti-malware Scan Interface (AMSI) integration with Microsoft Defender Antivirus - Microsoft Defender for Endpoint | Microsoft Learn](https://learn.microsoft.com/en-us/defender-endpoint/amsi-on-mdav#:~:text=,HackTool%3AWin32%2FMikatz%21dha))

16. Picus Security – *Process Hollowing (T1055.012)* (Giải thích tạo tiến trình suspended, hollowing bộ nhớ, thay bằng mã độc) ([MITRE ATT&CK T1055.012 Process Injection: Process Hollowing](https://www.picussecurity.com/resource/blog/t1055-012-process-hollowing#:~:text=Process%20Hollowing%20is%20a%20process,context%20of%20the%20target%20process))

17. Picus Security – *Process Hollowing* (Mã độc ẩn mình trong tiến trình hợp pháp, khó bị phát hiện vì chạy dưới ngữ cảnh tin cậy) ([MITRE ATT&CK T1055.012 Process Injection: Process Hollowing](https://www.picussecurity.com/resource/blog/t1055-012-process-hollowing#:~:text=Process%20hollowing%20is%20a%20technique,visible%20to%20the%20operating%20system))

18. Deep Instinct – *3 EDR Bypass Techniques* (Unhooking: tải ntdll.dll sạch để bypass hook EDR, EDR sẽ bị mù không giám sát được) ([3 EDR Bypass Techniques & How to Stop Them | Deep Instinct](https://www.deepinstinct.com/blog/edr-bypass-techniques-and-how-to-stop-them#:~:text=Unhooking%20refers%20to%20a%20method,for%20any%20API%20calls%20made))

19. SecurityWeek – *Hackers ‘Blind’ Security Products via ETW* (Nhóm APT và malware tắt ETW Logging để qua mặt sản phẩm EDR) ([New ETW Attacks Can Allow Hackers to 'Blind' Security Products - SecurityWeek](https://www.securityweek.com/new-etw-attacks-can-allow-hackers-blind-security-products/#:~:text=Threat%20actors%2C%20including%20profit,campaign%2C%20and%20the%20LockerGoga%20ransomware))

20. BlackLanternSecurity – *Detecting Process Injection* (Khuyến nghị phát hiện injection bằng cách tìm các bước alloc, write, execute trong tiến trình – abstraction chung cho mọi kỹ thuật) ([Detecting Process Injection - by Adeem Mawani](https://blog.blacklanternsecurity.com/p/detecting-process-injection#:~:text=With%20the%20myriad%20of%20publicly,that%20we%20can%20potentially%20identify))

21. Microsoft Security Blog – *Uncovering cross-process injection with Windows Defender ATP* (Windows Defender ATP phát hiện nhiều kỹ thuật injection: CreateRemoteThread, QueueUserAPC, SetThreadContext… và cảnh báo SOC) ([Uncovering cross-process injection with Windows Defender ATP | Microsoft Security Blog](https://www.microsoft.com/en-us/security/blog/2017/03/08/uncovering-cross-process-injection-with-windows-defender-atp/#:~:text=Instead%20of%20using%20the%20more,QueueUserAPC%20to%20execute%20this%20code))

22. Deep Instinct – *EDR Hooks Unhooking Prevention* (EDR tiên tiến giám sát vùng nhớ hook, chặn mọi cố gắng sửa đổi hook – chống unhooking) ([3 EDR Bypass Techniques & How to Stop Them | Deep Instinct](https://www.deepinstinct.com/blog/edr-bypass-techniques-and-how-to-stop-them#:~:text=match%20at%20L859%20Just%20as,these%20memory%20areas%20are%20deemed))

